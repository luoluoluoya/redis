* Redis是一个键值对数据库服务器，服务器中通常包含着任意个非空数据库，而每个非 空数据库中又可以包含任意个键值对，为了方便起见，我们将服务器中的非空数据库以及它 们的键值对统称为数据库状态。
* 因为Redis是内存数据库，它将自己的数 据库状态储存在内存里面，所以如果不想办 法将储存在内存中的数据库状态保存到磁盘 里面，那么一旦服务器进程退出，服务器中的数据库状态也会消失不见。
* 为了解决这个问题，Redis提供了 RDB持久化功能，这个功能可以将Redis在内存中的 数据库状态保存到磁盘里面，避免数据意外丢失。
* RDB持久化既可以手动执行，也可以根据服务器配置选项定期执行，该功能可以将某 个时间点上的数据库状态保存到一个RDB文件中，如图10-2所示。
* RDB持久化功能所生成的RDB文件是一个经过压缩的二进制文件，通过该文件可以还 原生成RDB文件时的数据库状态。
* 因为RDB文件是保存在硬盘里面的，所以即使Redis服务器进程退出，甚至运行Redis 服务器的计算机停机，但只要RDB文件仍然存在，Redis服务器就可以用它来还原数据库 状态。

#### RDB文件的创建与载入

* 有两个Redis命令可以用于生成RDB文件，一个是 SAVE,另一个是 BGSAVE. SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞 期间，服务器不能处理任何命令请求：

* 和SAVE命令直接阻塞服务器进程的做法不同，BGSAVE命令会派生出一个子进程，然 后由子进程负责创建RDB文件，服务器进程(父进程)继续处理命令请求：

* 创建RDB文件的实际工作由rdb.c/rdbSave函数完成，岛吓命令和BGSAVE命令 会以不同的方式调用这个函数，通过以下伪代码可以明显地看出这两个命令之间的区别：

  ```c
  def SAVE ():
    #创建#庞文件
    rdbSave()
      
  def BGSAVE():
    #创建子进程
    pid = fork()
    if pid == 0:
      #子进程负责创建択如文件
      rdbSave()
      #完成之后向父进程发送信号
      signal_parent()
    elif pid > 0:
      #父进程继续处理命令请求，并通过轮询等待子进程的信号 handle_request_and_wait_signal()
  	else:
      #处理出错情况
      handle_fork_error()
  ```

* 和使用SAVE命令或者BGSAVE命令创建RDB文件不同，RDB文件的载入工作是在服 务器启动时自动执行的，所以Redis并没有专门用于载入RDB文件的命令，只要Redis服 务器在启动时检测到RDB文件存在，它就会自动载入RDB件。
* 另外值得一提的是，因为AOF文件的更新频率通常比RDB文件的更新频率高，所以： 
  * 如果服务器开启了 AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态。
  * 只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。 
* 载入RDB文件的实际工作由rdb . c/rdbLoad函数完成

#####  SAVE命令执行时的服务器状态

* 前面提到过，当SAVE命令执行时，Redis服务器会被阻塞，所以当SAVE命令正在执 行时，客户端发送的所有命令请求都会被拒绝。
* 只有在服务器执行完SAVE命令、重新开始接受命令请求之后，客户端发送的命令才会被处理。

##### BGSAVE命令执行时的服务器状态

* 因为BGSAVE命令的保存工作是由子进程执行的，所以在子进程创建RDB文件的过程 中，Redis服务器仍然可以继续处理客户端的命令请求，但是，在BGSAVE命令执行期间， 服务器处理SAVE、BGSAVE、BGREWRITEAOF三个命令的方式会和平时有所不同。
  * 首先，在BGSMVE命令执行期间，客户端发送的SAVE命令会被服务器拒绝，服务器禁止SAVE命令和BGSAVE命令同时执行是为了避免父进程（服务器进程）和子进程同时执行两个rdbSave调用，防止产生竞争条件。
  * 其次，在BGSAVE命令执行期间，客户端发送的BGSAVE命令会被服务器拒绝，因为同时执行两个BGSAVE命令也会产生竞争条件。
  * 最后，BGREWRITEAOF和BGSAVE两个命令不能同时执行：
    * 如果BGSAVE命令正在执行，那么客户端发送的BGREWRITEAOF命令会被延迟到 BGSAVE命令执行完毕之后执行。
    * 如果BGREWRITEAOF命令正在执行，那么客户端发送的BGSAVE命令会被服务器拒绝。
  * 因为BGREWRITEAOF和两个命令的实际工作都由子进程执行，所以这两个命令在操作方面并没有什么冲突的地方，不能同时执行它们只是一个性能方面的考虑——并发出两个子进程，并且这两个子进程都同时执行大量的磁盘写入操作，这怎么想都不会是一 个好主意。

##### RDB文件载入时的服务器状态

* 服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入工作完成为止。

#### 自动间隔性保存

* 在上一节，我们介绍了SAVE命令和BGSAVE的实现方法，并且说明了这两个命令在实现方面的主要区别：

  * SAVE命令由服务器进程执行保存工作，BGSAVE命令则由子进程执行保存工作，所以吓命令会阻塞服务器，而BGSAVE则不会。
  * 因为BGSAVE命令可以在不阻塞服务器进程的情况下执行，所以Redis允许用户通过设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令。
  * 用户可以通过save选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行BGSAVE命令。

* 举个例子，如果我们向服务器提供以下配置：

  ```
  save 900 1
  save 300 10
  save 60 10000
  ```

  那么只要满足以下三个条件中的任意一个，BGSSm命令就会被执行：

  * 服务器在900秒之内，对数据库进行了至少1次修改。
  * 服务器在300秒之内，对数据库进行了至少10次修改。
  * 服务器在60秒之内，对数据库进行了至少10000次修改。

##### 设置保存条件

* 当Redis服务器启动时，用户可以通过指定配置文件或者传入启动参数的方式设置save 选项，如果用户没有主动设置save选项，那么服务器会为save选项设置默认条件：

  ```
  save 900 1
  save 300 10
  save 60 10000
  ```

  接着，服务器程序会根据save选项所设置的保存条件，设置服务器状态redisServer 结构的saveparams属性：

  ```c
  struct redisServer {
    //记录了保存条件的数组 
    struct saveparam *saveparams;
    //
  ｝；
  ```

  saveparams属性是一个数组，数组中的每个元素都是一个saveparam结构，每个 saveparam结构都保存了一个save选项设置的保存条件：

  ```c
  struct saveparam (
    //秒数
    seconds;
    //修改数
    int changes;
  ｝；
  ```

##### dirty 计数器和 lastsave 属性

* 除了 saveparams数组之外，服务器状态还维持着一个dirty计数器，以及一个 lastsave 属性：

* dirty计数器记录距离上一次成功执行SAVE命令或者BGSAVE命令之后，服务器对数据库状态（服务器中的所有数据库）进行了多少次修改（包括写入、删除、更新等操作）

* lastsave属性是一个UNIX时间戳，记录了服务器上一次成功执行 SAVE 命令或者BGSAVE命令的时间。

  ```c
  struct redisServer （
    //修改计数器 
    long long dirty;
    //上一次执行保存的时间 
    time_t lastsave; 
  }
  ```

  当服务器成功执行一个数据库修改命令之后，程序就会对dirty计数器进行更新：命令修改了多少次数据库，dirty计数器的值就增加多少。

##### 检查保存条件是否满足

* Redis的服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置的保存条件是否已经满足，如果满足的话，就执行BGSAVE命令。

* 以下伪代码展示了 serverCron 函数检査保存条件的过程：

  ```
  def serverCron ():
  # ...
  #遍历所有保存条件
  for saveparam in server.saveparams:
  #计算距离上次执行保存操作有多少秒 
  save_interval = unixtime_now() - server.lastsave
  #如果数据库状态的修改次数超过条件所设置的次数
  #并且距离上次保存的时间超过条件所设置的时间
  #那么执行保存操作 
  if server.dirty >= saveparam.changes and \ save_interval > saveparam.seconds:
  
  BGSAVE()
  ```

  

程序会遍历并检查saveparams数组中的所有保存条件，只要有任意一个条件被满足, 那么服务器就会执行BGSAVE命令。