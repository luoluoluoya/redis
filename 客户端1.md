* Redis服务器是典型的一对多服务器程序：一个服务器可以与多个客户端建立网络连接， 每个客户端可以向服务器发送命令请求，而服务器则接收并处理客户端发送的命令请求，并 向客户端返回命令回复。

* 通过使用由I/O多路复用技术实现的文件事件处理器，Redis服务器使用单线程单进程 的方式来处理命令请求，并与多个客户端进行网络通信。

* 对于每个与服务器进行连接的客户端，服务器都为这些客户端建立了相应的redis.h/ redisClient结构(客户端状态)，这个结构保存了客户端当前的状态信息，以及执行相 关功能时需要用到的数据结构，其中包括：

  * 客户端的套接字描述符。
  * 客户端的名字。
  * 客户端的标志值(flag )o
  * 指向客户端正在使用的数据库的指针，以及该数据库的号码。
  * 客户端当前要执行的命令、命令的参数、命令参数的个数，以及指向命令实现函数 的指针。
  * 客户端的输入缓冲区和输出缓冲区。
  * 客户端的复制状态信息，以及进行复制所需的数据结构。
  * 客户端执行BRPOP、BLPOP等列表阻塞命令时使用的数据结构。
  * 客户端的事务状态，以及执行町4TCH命令时用到的数据结构。
  * 客户端执行发布与订阅功能时用到的数据结构。
  * 客户端的身份验证标志。
  * 客户端的创建时间，客户端和服务器最后一次通信的时间，以及客户端的输出缓冲 区大小超出软性限制(softlimit)的时间。

* Redis服务器状态结构的clients属性是一个链表，这个链表保存了所有与服务器连 接的客户端的状态结构，对客户端执行批量操作，或者查找某个指定的客户端，都可以通过 遍历clients链表来完成：

  ```c
  struct redisServer (
    // ...
    // 一个链表，保存了所有客户端状态
    list *clients;
    // ...
  }；
  ```

#### 客户端属性

* 客户端状态包含的属性可以分为两类：
  *  一类是比较通用的属性，这些属性很少与特定功能相关，无论客户端执行的是什么 工作，它们都要用到这些属性。
  * 另外一类是和特定功能相关的属性，比如操作数据库时需要用到的db属性和 dictid属性，执行事务时需要用到的instate属性，以及执行WATCH命令时需 要用到的watched_keys属性等等。

##### 套接字描述符

* 客户端状态的fd属性记录了客户端正在使用的套接字描述符：

  ```c
  typedef struct redisClient {
    //
    int fd;
    // ・..
  } redisClient;
  ```

* 根据客户端类型的不同，fd属性的值可以是-1或者是大于-1的整数：

  * 伪客户端(fake client)的fd属性的值为-1:伪客户端处理的命令请求来源于AOF 文件或者Lua脚本，而不是网络，所以这种客户端不需要套接字连接，自然也不需 要记录套接字描述符。目前Redis服务器会在两个地方用到伪客户端，一个用于载 入AOF文件并还原数据库状态，而另一个则用于执行Lua脚本中包含的Redis命令。
  * 普通客户端的fd属性的值为大于-1的整数：普通客户端使用套接字来与服务器进行通信，所以服务器会用fd属性来记录客户端套接字的描述符。因为合法的套接字描述符不能是-1,所以普通客户端的套接字描述符的值必然是大于-1的整数。

* 执行CLIENT list命令可以列出目前所有连接到服务器的普通客户端，命令输出中的fd 域显示了服务器连接客户端所使用的套接字描述符：

  ```CQL
  redis> CLIENT list
  addr=127.0.0.1:53428 fd=6 name= age=1242 idle=0 ...
  addr=127.0.0.1:53469 fd=7 name= age=4 idle=4 ...
  ```

##### 名字

* 在默认情况下，一个连接到服务器的客户端是没有名字的。

* 使用CLIENT setname兪令可以为客户端设置一个名字，让客户端的身份变得更清晰。

* 客户端的名字记录在客户端状态的name属性里面：

  ```c
  typedef struct redisClient {
    // ...
    robj *name;
    // ...
  } redisClient;
  ```

* 如果客户端没有为自己设置名字，那么相应客户端状态的name属性指向NULL指 针；相反地，如果客户端为自己设置了名字，那么 name属性将指向一个字符串对象，而该对象就保 存着客户端的名字。

* 