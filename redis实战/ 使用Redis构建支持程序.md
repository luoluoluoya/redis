#### 使用 Redis 来记录日志

* 在构建应用程序和服务的过程中，对正在运行的系统的相关信息的挖掘能力将变得越来越重 要：无论是通过挖掘信息来诊断系统问题，还是发现系统中潜在的问题，甚至是挖掘与用户有 关的信息——这些都需要用到日志。
* 在Linux和Unix的世界中，有两种常见的记录日志的方法。第一种是将日志记录到文件 里面，然后随着时间流逝不断地将一个又一个日志行添加到文件里面，并在一段时间之后创 建新的日志文件。包括Redis在内的很多软件都使用这种方法来记录日志。但这种记录日志 的方式有时候可能会遇上麻烦：因为每个不同的服务都会创建不同的日志，而这些服务轮换 (rolling )日志的机制也各不相同，并且也缺少一种能够方便地聚合所有日志并对其进行处理的常用方法。
* syslog服务是第二种常用的日志记录方法，这个服务运行在几乎所有Linux服务器和Unix 服务器的514号TCP端口和UDP端口上面。syslog接受其他程序发来的日志消息，并将这些消 息路由（route）至存储在硬盘上的各个日志文件里面，除此之外，syslog还负责旧日志的轮换和 删除工作。通过配置，syslog甚至可以将日志消息转发给其他服务来做进一步的处理。因为对指 定日志的轮换和删除工作都可以交给syslog来完成，所以使用syslog服务比直接将日志写入文件 要方便得多。
* 替换syslog
  * 无论读者使用上面列举的两种日志记录方法中的哪一种，都最好考虑把系统目前的syslog守护进程（通常是Rsyslogd ）替换成syslog-ngo因为我经过使用并配置Rsyslogd 和syslog-ng之后，发现syslog-ng用于管理和组织日志消息的配置语言使用起来更简单 一些。另外，尽管因为时间和篇幅所限，我没办法在书中构建一个处理syslog消息并将消息存 储到Redis里面的服务，但对于那些需要在处理请求时立即执行的操作，以及那些可以在请求 处理完毕之后再执行的操作（如记录日志和更新计数器）来说，这种服务非常适合用作介于 这两种操作之间的间接层。
* syslog的转发功能可以将不同的日志分别存储到同一台服务器的多个文件里面，这对于长时 间地记录日志非常有帮助（记得备份）。

#### 最新日志

* 在构建一个系统的时候，判断哪些信息需要被记录是一件困难的事情：需要记录用户 的登入和登出行为吗？需要记录用户修改账号信息的时间吗？还是只记录错误和异常就可 以了？虽然我没办法替你回答这些问题，但我可以向你提供一种将最新出现的日志消息以 列表的形式存储到Redis里面的方法，这个列表可以帮助你随时了解最新出现的日志都是什 么样子的。

##### 常见日志

* 程序会将 消息作为成员存储到有序集合里面，并将消息出现的频率设置为成员的分值。为了确保我们看见 的常见消息都是最新的，程序会以每小时一次的频率对消息进行轮换，并在轮换日志的时候保留 上一个小时记录的常见消息，从而防止没有任何消息存在的情况出现。

#### 计数器和统计数据

* 通过记录各个页面的被访问次数，我们可以根据基本的访问计数信息来决 定如何缓存页面。
* 知道我们的网站在最近5分钟内获得了 10 000次点击，或者数据库在最近5秒内处理了 200 次写入和600次读取，是非常有用的。通过在一段时间内持续地记录这些信息，我们可以注意到 流量的骤增或渐增情况，预测何时需要对服务器进行升级，从而防止系统因为负荷超载而下线。

##### 将计数器存储到Redis里面

* 在监控应用程序的同时，持续地收集信息是一件非常重要的事情。那些影响网站响应速度以及网 站所能服务的页面数量的代码改动、新的广告营销活动或者是刚刚接触系统的新用户，都有可能会彻 底地改变网站载入页面的数量，并因此而影响网站的各项性能指标。但如果我们平时不记录任何指标 数据的话，我们就不可能知道指标发生了变化，也就不可能知道网站的性能是在提高还是在下降。
* 实现计数器首先要考虑的就是如何存储计数器信息

###### 对计数器进行更新

* 为了对计数器进行更新，我们需要存储实际的计数器信息。对于每个计数器以及每种精度， 如网站点击量计数器和5秒，我们将使用一个散列来存储网站在每个5秒时间片(time slice )之 内获得的点击量，其中，散列的每个键都是某个时间片的开始时间，而键对应的值则存储了网站 在该时间片之内获得的点击量。
* 为了能够清理计数器包含的旧数据，我们需要在使用计数器的同时，对被使用的计数器进行记录。为了做到这一点，我们需要一个有序序列(ordered sequence ),这个序列不能包含任何重复元素，并且能够让我们一个接一个地遍历序列中包含的所有元素。虽然同时使用列表和集合可以实现这种序列，但同时使用两种数据结构需要编写更多代码，并且会增加客户端和Redis之间的通信往返次数。实际上，实现有序序列更好的办法是使用有序集合，有序集合的各个成员分别 由计数器的精度以及计数器的名字组成，而所有成员的分值都为0。因为所有成员的分值都被设置成了 0,所以Redis在尝试按分值对有序集合进行排序的时候，就会发现这一点，并改为使用 成员名进行排序，这使得一组给定的成员总是具有固定的排列顺序，从而可以方便地对这些 成员进行顺序性的扫描。

###### 清理旧计数器

* 如果我们只是一味地对计数器进行更新而不执行任何清理操作的话，那么程序最终将 会因为存储了过多的数据而导致内存不足。好在我们事先已经将所有已知的计数器都记录到了一个 有序集合里面，所以对计数器进行清理只需要遍历有序集合并删除其中的旧计数器就可以了。
* 为什么不使用EXPIRE? 
  * expire命令的其中一个限制就是它只能应用于整个键，而不能只对键 的某一部分数据进行过期处理。并且因为我们将同一个计数器在不同精度下的所有计数数据都存放 到了同一个键里面，所以我们必须定期地对计数器进行清理。
* 在处理（process ）和清理（clean叩）旧计数器的时候，有几件事情是需要我们格外留心的， 其中包括以下几件。
  * 任何时候都可能会有新的计数器被添加进来。
  * 同一时间可能会有多个不同的清理操作在执行。
  * 对于一个每天只更新一次的计数器来说，以每分钟一次的频率尝试清理这个计数器只会浪费计算资源。
  * 如果一个计数器不包含任何数据，那么程序就不应该尝试对它进行清理。
* 为了尽可能地降低清理操作的执行负载， 守护进程会以每分钟一次的频率清理那些每分钟更新一次或者每分钟更新多次的计数器，而对于那些更新频率低于每分钟一次的计数器，守护进程则会根据计数器自身的更新频率来决定对它们进行清理的频率。比如说，对于每秒更新一次或者每5秒更新一次的计数器，守护进程将以每分钟一次的频率清理这些计数器；而对于每5分钟更新一次的计数器，守护进程将以每5分钟一次的频率清理这些计数器。
* 清理程序通过对记录已知计数器的有序集合执行ZRANGE命令来一个接一个的遍历所有已知的计数器。在对计数器执行清理操作的时候，程序会取出计数器记录的所有计数样本的开始时间， 并移除那些开始时间位于指定截止时间之前的样本，清理之后的计数器最多只会保留最新的120个 样本。如果一个计数器在执行清理操作之后不再包含任何样本，那么程序将从记录已知计数器的有序集合里面移除这个计数器的引用信息。
* 正如之前所说，clean_counters ()函数会一接一个地遍历有序集合里面记录的计数器， 查找需要进行清理的计数器。程序在每次遍历时都会对计数器进行检查，确保只清理应该清理的 计数器。当程序尝试清理一个计数器的时候，它会取出计数器记录的所有数据样本，并判断哪些样本是需要被删除的。如果程序在对一个计数器执行清理操作之后，认为这个计数器已经不再包 含任何数据，那么程序会检查这个计数器是否已经被清空，并在确认了它已经被清空之后，将它 从记录已知计数器的有序集合中移除。最后，在遍历完所有计数器之后，程序会计算此次遍历耗 费的时长，如果为了执行清理操作而预留的一分钟时间没有完全耗尽，那么程序将休眠直到这一 分钟过去为止，然后继续进行下次遍历。
* 在和一个真实的网站打交道的时候，知道页面每天的点击量可以帮助我们判断是否需要对页面进行缓存。但是，如果被频繁访问的页面只需要花费2毫秒来进行渲染，而其他流量只有十分之一的页面却需要花费2秒来进行渲染，那么在缓存被频繁访问的页面之前，我们可以先将注意 力放到优化渲染速度较慢的页面上面。

##### 使用Redis存储统计数据

* 对于一种给定的上下文(context)和类型，程序将使用一个有序集合来记录这个上下文以及这个类型的最小值(min)、最大值(max )、 样本数量(count)值的和(sum )、值的平方之和(sumsq )等信息，并通过这些 信息来计算平均值以及标准差。程序将 值存储在有序集合里面并非是为了按照 分值对成员进行排序，而是为了对存储 着统计信息的有序集合和其他有序集合 进行并集计算，并通过MIN和MAX这两个聚合函数来筛选相交的元素。
* 既然我们已经知道了程序要存储的是什么类型的数据，那么接下来要考虑的就是如何将这些数据 写到数据结构里面了。统计程序在写入数据之前会进行检查，确保被记录的是当前这个小时的统计数据，并将不属于当前这个小时的旧数据进行归档。在此之后，程序会构建两个临时有序集合，其中一个用于保存最小值，而另一个则用于保存最大值。然后使用ZUNIONST0RE命令以及它的两个聚合函数MIN和MAX, 分别计算两个临时有序集合与记录当前统计数据的有序集合之间的并集结果。通过使用ZUNIONSTORE 命令，程序可以快速地更新统计数据，而无需使用WATCH去监视可能会频繁进行更新的存储统计数据 的键，因为这个键可能会频繁地进行更新。程序在并集计算完毕之后就会删除那些临时有序集合，并使用ZINCRBY命令对统计数据有序集合里面的count、sum. sumsq这3个成员进行更新。

##### 简化统计数据的记录与发现

* 在将统计数据存储到Redis里面之后，接下来我们该做些什么呢？说得更详细一点，在知道了访问每个页面所需的时间之后，我们要怎样才能找到那些生成速度较慢的网页？或者说，当某个页面的生成速度变得比以往要慢的时候，我们如何才能知悉这一情况？简单来说，为了发现以上提到的这些情况，我们需要存储更多信息。
* 要记录页面的访问时长，程序就必须在页面被访问时进行计时。为了做到这一点，我们可以 在各个不同的页面设置计时器，并添加代码来记录计时的结果，但更好的办法是直接实现一个能够进行计时并将计时结果存储起来的东西，让它将平均访问速度最慢的页面都记录到一个有序集合里面，并向我们报告哪些页面的载入时间变得比以前更长了。
* 

