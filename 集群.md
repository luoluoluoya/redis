* Redis集群是Redis提供的分布式数据库方案，集群通过分片(sharding )来进行数据共享，并提供复制和故障转移功能。

#### 节点

* 一个Redis集群通常由多个节点(node)组成，在刚开始的时候，每个节点都是相互独立的，它们都处于一个只包含自己的集群当中，要组建一个真正可工作的集群，我们必须将各个独立的节点连接起来，构成一个包含多个节点的集群。

* 连接各个节点的工作可以使用 `CLUSTER MEET` 命令来完成，该命令的格式如下：`CLUSTER MEET <ip> <port>` 

* 向一个节点node发送CLUSTER MEET命令，可以让node节点与ip和port所指定的节点进行握手(handshake ),当握手成功时，node节点就会将ip和port所指定的节点添加到node节点当前所在的集群中。

* 举个例子，假设现在有三个独立的节点`127.0.0.1:7000. 127.0.0.1:7001. 127.0.0.1:7002` (下文省略IP地址，直接使用端口号来区分各个节点)，我们首先使用客户端连上节点7000, 通过发送CLUSTER NODES命令可以看到，集群目前只包含7000自己一个节点：

  ```
  $ redis-cli -c -p 7000
  127.0.0.1:7000> CLUSTER NODES
  51549e625cfda318ad27423a31e7476fe3cd2939 :0 myself,master -000 connected
  ```

  通过向节点7000发送以下命令，我们可以将节点7001添加到节点7000所在的集群 里面：

  ```
  127.0.0.1:7000> CLUSTER MEET 127.0.0.1 7001
  0K
  127.0.0.1:7000> CLUSTER NODES
  68eef66df23420a5862208ef5bla7005b806f2ff 127.0.0.1:7001 master - 0 1388204746210 0 connected
  51549e625cfda318ad27423a31e7476fe3cd2939 :0 myself, master -000 connected
  ```

  继续向节点7000发送以下命令，我们可以将节点7002也添加到节点7000和节点7001所在的集群里面

  ```
  127.0.0.1:7000> CLUSTER MEET 127.0.0.1 7002
  OK
  127.0.0.1:7000> CLUSTER NODES
  68eef66df23420a5862208ef5bla7005b806f2ff 127.0.0.1:7001 master - 0 1388204848376 0 connected
  9dfb4c4e016e627d9769e4c9bb0d4fa208e65c26 127.0.0.1:7002 master - 0 1388204847977 0 connected
  51549e625cfda318ad27423a31e7476fe3cd2939 :0 myself,master -000 connected
  ```

  现在，这个集群里面包含了 7000、7001和7002三个节点。

##### 启动节点

* 一个节点就是一个运行在集群模式下的Redis服务器，Redis服务器在启动时会根据 `cluster-enabled` 配置选项是否为yes来决定是否开启服务器的集群模式。
* 节点（运行在集群模式下的Redis服务器）会继续使用所有在单机模式中使用的服务器组件，比如说：
  * 节点会继续使用文件事件处理器来处理命令请求和返回命令回复。
  * 节点会继续使用时间事件处理器来执行serverCron函数，而serverCron函数又会调用集群模式特有的clusterCron函数。clusterCron函数负责执行在集群模式下需要执行的常规操作，例如向集群中的其他节点发送Gossip消息，检査节点是否断线，或者检査是否需要对下线节点进行自动故障转移等。
  * 节点会继续使用数据库来保存键值对数据，键值对依然会是各种不同类型的对象。
  * 节点会继续使用RDB持久化模块和AOF持久化模块来执行持久化工作。
  * 节点会继续使用发布与订阅模块来执行 PUBLISH, SUBSCRIBE 等命令。
  * 节点会继续使用复制模块来进行节点的复制工作。
  * 节点会继续使用Lua脚本环境来执行客户端输入的Lua脚本。
  * 除此之外，节点会继续使用redisServer结构来保存服务器的状态，使用 redisClient结构来保存客户端的状态，至于那些只有在集群模式下才会用到的数据，节点将它们保存到了 cluster.h/clusterNode 结构、cluster.h/clusterLink 结构，以 及cluster.h/clusterState结构里面。

##### 集群数据结构

* clusterNode结构保存了一个节点的当前状态，比如节点的创建时间、节点的名字、 节点当前的配置纪元、节点的IP地址和端口号等等。

* 每个节点都会使用一个clusterNode结构来记录自己的状态，并为集群中的所有其他节点（包括主节点和从节点）都创建一个相应的clusterNode结构，以此来记录其他节点的状态：

  ```c
  struct clusterNode {
  
    //创建节点的时间
    mstime_t ctime;
  
    //节点的名字，由40个十六进制字符组成
    // 例如 68eef66df2 3420a5862208ef5bla7005b806f2ff
    char name[REDIS_CLUSTER_NAMELEN];
  
    //节点标识
    //使用各种不同的标识值记录节点的角色（比如主节点或者从节点）,
    //以及节点目前所处的状态（比如在线或者下线）。
    int flags;
  
    //节点当前的配置纪元，用于实现故障转移
    uint64_t configEpoch;
  
    //节点的IP地址
    char ip[REDIS_IP_STR_LEN];
  
    //节点的端口号
    int port;
  
    //保存连接节点所需的有关信息
    clusterLink *link;
  
    // ...
  
  ｝；
  ```

* clusterNode结构的 link 属性是一个clusterLink结构，该结构保存了连接节点所需的有关信息，比如套接字描述符，输入缓冲区和输出缓冲区：

  ```c
  typedef struct clusterLink {
  
    //连接的创建时间
    mstime_t ctime;
  
    // TCP套接字描述符
    int fd;
  
    //输出缓冲区，保存着等待发送给其他节点的消息（message ）
    sds sendbuf;
  
    //输入缓冲区，保存着从其他节点接收到的消息。
    sds rcvbuf;
  
    //与这个连接相关联的节点，如果没有的话就为NULL
    struct clusterNode *node;
  
  } clusterLink;
  ```

* redisClient结构和clusterLink结构的相同和不同之处

  * redisClient结构和clusterLink结构都有自己的套接字描述符和输入、输出 缓冲区，这两个结构的区别在于，redisClient结构中的套接字和缓冲区是用于连接客户端的，而clusterLink结构中的套接字和缓冲区则是用于连接节点的。

* 最后，每个节点都保存着一个clusterstate结构，这个结构记录了在当前节点的视角下，集群目前所处的状态，例如集群是在线还是下线，集群包含多少个节点，集群当前的配置纪元，诸如此类：

  ```c
  typedef struct clusterstate {
  
    //指向当前节点的指针 
    clusterNode *myself;
  
    //集群当前的配置纪元，用于实现故障转移 
    uint64_t currentEpoch;
  
    //集群当前的状态：是在线还是下线
    int state;
  
    //集群中至少处理着一个槽的节点的数量
    int size;
  
    //集群节点名单（包括myself节点）
    //字典的键为节点的名字，字典的值为节点对应的clusterNode结构 
    diet *nodes;
  
    // ...
  
  } clusterstate;
  ```

##### CLUSTER MEET 命令的实现

* 通过向节点A发送CLUSTER MEET命令, 客户端可以让接收命令的节点A将另一个节点B添加到节点A当前所在的集群里面：`CLOSTER MEET <ip> <port>`
* 收到命令的节点A将与节点B进行握手（handshake ）,以此来确认彼此的存在，并为将来的进一步通信打好基础：
  1. 节点A会为节点B创建一个clusterNode结构，并将该结构添加到自己的 clusterstate.nodes 字典里面。之后，节点A将根据MEET命令给定的IP地址和端口号，向节点B发送一条 MEET 消息（message ）。
  2. 如果一切顺利，节点B将接收到节点A发送的MEET消息，节点B会为节点A创建一个clusterNode结构，并将该结构添加到自己的clusterstate.nodes字典里面。之后，节点B将向节点A返回一条PONG消息。
  3. 如果一切顺利，节点A将接收到节点B返回的PONG消息，通过这条PONG消息节 点A可以知道节点B已经成功地接收到了自己发送的MEET消息。之后，节点A将向节点B返回一条PING消息。
  4. 如果一切顺利，节点B将接收到节点A返回的PING消息，通过这条PING消息节点B可以知道节点A已经成功地接收到了自己返回的PONG消息，握手完成。
  5. 之后，节点A会将节点B的信息通过Gossip协议传播给集群中的其他节点,让其他节点也与节点B进行握手，最终，经过一段时间之后，节点B会被集群中的所有节点认识。

#### 槽指派

* Redis集群通过分片的方式来保存数据库中的键值对：集群的整个数据库被分为16384 个槽（slot）,数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点可以处理0个或最多16384个槽。

* 当数据库中的16384个槽都有节点在处理时，集群处于上线状态（ok）；相反地，如果数据库中有任何一个槽没有得到处理，那么集群处于下线状态（fail）。

* 在上一节，我们使用 CLUSTER MEET 命令将7000、7001、7002三个节点连接到了同 一个集群里面，不过这个集群目前仍然处于下线状态，因为集群中的三个节点都没有在处理任何槽

* 通过向节点发送 CLUSTER ADDSLOTS 命令，我们可以将一个或多个槽指派(assign )给节点负责: `CLUSTER ADDSLOTS <slot> [slot ...]`

* 举个例子，执行以下命令可以将槽0至槽5000指派给节点7000负责: `127.0.0.1:7000> CLUSTER ADDSLOTS 0 1 2 3 5 ... 500

  ```
  127.0.0.1:7000> CLUSTER NODES
  9dfb4c4e016e627d9769e4c9bb0d4fa208e65c26 127.0.0.1:7002 master - 0 1388316664849 0 connected
  68eef66df23420a5862208ef5bla7005b806f2ff 127.0.0.1:7001 master - 0 1388316665850 0 connected
  51549e625cfda318ad27423a31e7476fe3cd2939 :0 myself,master -000 connected 0-5000 
  ```

  为了让7000、7001、7002三个节点所在的集群进入上线状态，我们继续执行以下命令， 将槽5001至槽10000指派给节点7001负责：`127.0.0.1:7001> CLUSTER ADDSLOTS 5001 5002 5003 5004 ... 10000`然后将槽10001至槽16383指派给7002负责：`127.0.0.1:7002> CLUSTER ADDSLOTS 10001 10002 10003 10004 ... 16383` 当以上三个CLUSTER ADDSLOTS命令都执行完毕之后，数据库中的16384个槽都已经被指派给了相应的节点，集群进入上线状态

  ```
  127.0.0.1:7000> CLUSTER NODES
  9dfb4c4e016e627d9769e4c9bb0d4fa208e65c26 127.0.0.1:7002 master 0 connected 10001-16383
  68eef66df23420a5862208ef5bla7005b806f2ff 127.0.0.1:7001 master - 0 1388317427167 0 connected 5001-10000
  51549e625cfda318ad27423a31e7476fe3cd2939 :0 myself,master -0 0 0 connected 0-5000 
  ```

##### 记录节点的槽指派信息

* clusterNode结构的slots属性和numslot属性记录了节点负责处理哪些槽：

  ```c
  struct clusterNode {
    unsigned char slots[16384/8];
    int numslots;
    // ...
  }
  ```

* slots属性是一个二进制位数组(bit array),这个数组的长度为16384/8=2048个字 节，共包含16384个二进制位。
* Redis以0为起始索引，16383为终止索引，对slots数组中的16384个二进制位进行编号，并根据索引i上的二进制位的值来判断节点是否负责处理槽i：

□如果Slots数组在索引i上的二进制位的值为1,那么表示节点负责处理槽io

□如果Slots数组在索引i上的二进制位的值为0,那么表示节点不负责处理槽io

图17-9展示了一个slots数组示例：这个数组索引0至索引7上的二进制位的值都为

1,其余所有二进制位的值都为0,这表示节点负责处理槽0至槽7。

| 字节 | slots[0] | slots[1] ~ slots[2047] |      |      |      |      |      |      |      |      |      |      |      |      |       |       |       |
| ---- | -------- | ---------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ----- | ----- | ----- |
| 索引 | 0        | 1                      | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |      | 16381 | 16382 | 16383 |
| 值   | 1        | 1                      | 1    | 1    | 1    | 1    | 1    | 1    | 0    | 0    | 0    | 0    | 0    |      | 0     | 0     | 0     |

 

图17-9 一个slots数组示例

图17-10展示了另一个slots数组示例：这个数组索引1、3、5、8、9、10上的二进制 位的值都为1,而其余所有二进制位的值都为0,这表示节点负责处理槽I、3、5、8、9、10。

| 字节 | slots[0] | slots[1] |      | slots[2047] |      |      |      |      |      |      |      |      |      |      |      |      |      |      |       |       |
| ---- | -------- | -------- | ---- | ----------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ----- | ----- |
| 索引 | 0        | 1        | 2    | 3           | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   |      |      | 16382 | 16383 |
| 值   | 0        | 1        | 0    | 1           | 0    | 1    | 0    | 0    | 1    | 1    | 1    | 0    | 0    | 0    | 0    | 0    | ...  |      | 0     | 0     |



因为取出和设置slots数组中的任意一个二进制位的值的复杂度仅为0(1),所以对于 一个给定节点的slots数组来说，程序检査节点是否负责处理某个槽，又或者将某个槽指 派给节点负责，这两个动作的复杂度都是0(l)o

至于numslots属性则记录节点负责处理的槽的数量，也即是slots数组中值为1的 二进制位的数量。

比如说，对于图17-9所示的slots数组来说，节点处理的槽数量为8,而对于图 17-10所示的slots数组来说，节点处理的槽数量为6。



