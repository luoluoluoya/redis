#### 服务器中的数据库

* Redis服务器将所有数据库都保存在服务器状态redis.h/redisServer结构的db 数组中，db数组的每个项都是一个redis.h/redisDb结构，每个redisDb结构代表一个数据库：

  ```c
  struct redisServer {
      //...
      // 一个数组，保存着服务器中的所有数据库
      redisDb *db;
      // ...
  };
  ```

* 在初始化服务器时，程序会根据服务器状态的dbnum属性来决定应该创建多少个数据库

  ```c
  struct redisServer {
      // ...
      //服务器的数据库数量
      int dbnum;
      // ...
  }；
  ```

* dbnum属性的值由服务器配置的database选项决定，默认情况下，该选项的值为 16,所以Redis服务器默认会创建16个数据库

  ![image](E:\Learn\repository\learning-stl\imgs\28.png)

#### 切换数据库

* 每个Redis客户端都有自己的目标数据库，每当客户端执行数据库写命令或者数据库读命令的时候，目标数据库就会成为这些命令的操作对象。

* 默认情况下，Redis客户端的目标数据库为0号数据库，但客户端可以通过执行 SELECT命令来切换目标数据库。

* 在服务器内部，客户端状态redisClient结构的db属性记录了客户端当前的目标数 据库，这个属性是一个指向redisDb结构的指针：

  ```c++
  typedef struct redisClient {
      // ...
      //记录客户端当前正在使用的数据库
      redisDb *db;
      //
  } redisClient;
  ```

  redisClient.db指针指向redisServer.db数组的其中一个元素，而被指向的元素就是客户端的目标数据库。

* 比如说，如果某个客户端的目标数据库为1号数据库，那么这个客户端所对应的客户端 状态和服务器状态之间的关系如图

  ![image](E:\Learn\repository\learning-stl\imgs\29.png)

* 如果这时客户端执行命令SELECT 2,将目标数据库改为2号数据库，那么客户端状态 和服务器状态之间的关系将更新成图

  ![image](E:\Learn\repository\learning-stl\imgs\30.png)

* 通过修改redisClient.db指针，让它指向服务器中的不同数据库，从而实现切换目标数据库的功能——这就是 SELECT 命令的实现原理。
* 谨慎处理多数据库程序
  * 到目前为止，Redis仍然没有可以返回客户端目标数据库的命令。虽然redis-cli 客户端会在输入符旁边提示当前所使用的目标数据库
  * 但如果你在其他语言的客户端中执行Redis命令，并且该客户端没有像redis-cli那 样一直显示目标数据库的号码，那么在数次切换数据库之后，你很可能会忘记自己当前 正在使用的是哪个数据库。当出现这种情况时，为了避免对数据库进行误操作，在执 行Redis命令特别是像FZU5HDB这样的危险命令之前，最好先执行一个SELECT命令， 显式地切换到指定的数据库，然后才执行别的命令。

#### 数据库键空间

* Redis是一个键值对(key-value pair )数据库服务器，服务器中的每个数据库都由 一个redis.h/redisDb结构表示，其中，redisDb结构的 dict 字典保存了数据库中的所有键值对，我们将这个字典称为键空间(key space)

  ```CQL
  typedef struct redisDb (
      // ...
      //数据库键空间，保存着数据库中的所有键值对
      diet *dict;
      // ...
  } redisDb;
  ```

* 键空间和用户所见的数据库是直接对应的：

  * 键空间的键也就是数据库的键，每个键都是一个字符串对象。
  * 键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、 集合对象和有序集合对象中的任意一种Redis对象。

* 举个例子，如果我们在空白的数据库中执行以下命令：

  ```
  redis> SET message nhello world**
  OK
  
  redis> RPUSH alphabet "a” Hb" ”c”
  (integer)3
  
  redis> HSET book name "Redis in Action"
  (integer) 1
  
  redis> HSET book author "Josiah L. Carlson*'
  (integer) 1
  
  redis> HSET book publisher "Manning" (integer) 
  ```

  ![image](E:\Learn\repository\learning-stl\imgs\31.png)

* 因为数据库的键空间是一个字典，所以所有针对数据库的操作，比如添加一个键值对到数据库，或者从数据库中删除一个键值对，又或者在数据库中获取某个键值对等，实际上都是通过对键空间字典进行操作来实现的

##### 添加新键

* 添加一个新键值对到数据库，实际上就是将一个新键值对添加到键空间字典里面，其中 键为字符串对象，而值则为任意一种类型的Redis对象。

* 举个例子，如果键空间当前的状态如上图所示，那么在执行以下命令之后：`redis> SET date "2013.12.1"`。键空间将添加一个新的键值对，这个新键值对的键是一个包含字符串"date"的字符串对 象，而键值对的值则是一个包含字符串"2013.12.1 "的字符串对象

  ![image](E:\Learn\repository\learning-stl\imgs\35.png)

##### 删除键

* 删除数据库中的一个键，实际上就是在键空间里面删除键所对应的键值对对象。

##### 更新键

* 对一个数据库键进行更新，实际上就是对键空间里面键所对应的值对象进行更新，根据 值对象的类型不同，更新的具体方法也会有所不同。

##### 对键取值

* 对一个数据库键进行取值，实际上就是在键空间中取岀键所对应的值对象，根据值对象 的类型不同，具体的取值方法也会有所不同。

##### 其他键空间操作

* 除了上面列出的添加、删除、更新、取值操作之外，还有很多针对数据库本身的 Redis 命令，也是通过对键空间进行处理来完成的。
* 比如说，用于清空整个数据库的 FLUSHDB 命令，就是通过删除键空间中的所有键值对 来实现的。又比如说，用于随机返回数据库中某个键的 RANDOMKEY 命令，就是通过在键 空间中随机返回一个键来实现的。
* 另外，用于返回数据库键数量的 DBSIZE 命令，就是通过返回键空间中包含的键值对的数量来实现的。类似的命令还有 EXISTS, RENAME, KEYS 等,这些命令都是通过对键空间进行操作来实现的。

##### 读写键空间时的维护操作

* 当使用Redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作， 还会执行一些额外的维护操作，其中包括：
  * 在读取一个键之后（读操作和写操作都要对键进行读取）,服务器会根据键是否存在 来更新服务器的键空间命中（hit）次数或键空间不命中（miss）次数，这两个值可 以在 INFO stats 命令的 keyspace_hits 属性和 keyspace_misses 属性中查看。
  * 在读取一个键之后，服务器会更新键的 LRU （最后一次使用）时间，这个值可以用于 计算键的闲置时间，使用 OBJECT idletime 命令可以査看键key的闲置时间。
  * 如果服务器在读取一个键时发现该键已经过期，那么服务器会先删除这个过期键后才执行余下的其他操作
  * 如果有客户端使用 WATCH 命令监视了某个键，那么服务器在对被监视的键进行修 改之后，会将这个键标记为脏(dirty ),从而让事务程序注意到这个键已经被修改过。
  * 服务器每次修改一个键之后，都会对脏(dirty )键计数器的值增1,这个计数器会触 发服务器的持久化以及复制操作。
  * 如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知。

##### 设置键的生存时间或过期时间

* 通过EXPIRE命令或者PEXPIRE命令，客户端可以以秒或者毫秒精度为数据库中的某 个键设置生存时间(Time To Live, TTL ),在经过指定的秒数或者毫秒数之后，服务器就会 自动删除生存时间为0的键
* SE7EX命令可以在设置一个字符串键的同时为键设置过期时间，这个命令是一个 类型限定的命令(只能用于字符串键)，但SETEX命令 设置过期时间的原理和EXPIRE命令设置过期时间的原理是完全一样的
* 与EXPIRE命令和PEXPIRE命令类似，客户端可以通过EXPIREAT命令或PEXPIREAT 命令，以秒或者毫秒精度给数据库中的某个键设置过期时间(expire time)
* 过期时间是一个UNIX时间戳，当键的过期时间来临时，服务器就会自动从数据库中删除这个键
* TTL命令和PTTL命令接受一个带有生存时间或者过期时间的键，返回这个键的剩余生 存时间，也就是，返回距离这个键被服务器自动删除还有多长时间

##### 设置过期时间

* Redis有四个不同的命令可以用于设置键的生存时间(键可以存在多久)或过期时间 (键什么时候会被删除)：

  * EXPIRE \<key>\<ttl>命令用于将键key的生存时间设置为ttl秒
  * PEXPIRE \<key>\<ttl>命令用于将键key的生存时间设置为ttl毫秒。
  * EXPIREAT\<key>\<timestamp>命令用于将键key的过期时间设置为timestamp所指定的秒数时间戳。
  * PEXPIREAT \<key>\<timestamp>命令用于将键key的过期时间设置为timestamp 所指定的毫秒数时间戳。
  * 虽然有多种不同单位和不同形式的设置命令，但实际上EXPIRE 、PEXPIRE. EXPIREAT 三个命令都是使用PEXPIREAT命令来实现的：无论客户端执行的是以上四个命令中的哪一 个，经过转换之后，最终的执行效果都和执行PEXPIREAT命令一样。

  ```c
  #首先，EXPIRE命令可以转换成PEXPIRE命令：
  def EXPIRE(key,ttl_in_sec):
      #将TTL从秒转换成毫秒
      ttl_in_ms = sec_to_ms(ttl_in_sec)
      PEXPIRE(key, ttl_in_ms)
      
  #接着,PEXPIRE命令又可以转换成PEXPIREAT^:
  def PEXPIRE(key,ttl_in_ms):
      #获取以毫秒计算的当前 UNIX 时间戳
      now_ms = get_curren t_u n i x_t ime s t amp_i n_ms()
      #当前时间加上TTL，得出毫秒格式的键过期时间 	                 PEXPIREAT(key,now_ms+ttl_in_ms)
      
  #并且，EXPIREAT命令也可以转换成PEXFZREAT命令:
  def EXPIREAT(key,expire_time_in_sec):
  #将过期时间从秒转换为毫秒 
      expire_time_in_ms = sec_to_ms (expire_time_in_sec)
      PEXPIREAT (key, expire_time_in_ms)
  ```

  ![image](E:\Learn\repository\learning-stl\imgs\32.png)

##### 保存过期时间

* redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典：

  * 过期字典的键是一个指针，这个指针指向键空间中的某个键对象(也即是某个数据库键)。

  * 过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间。一个毫秒精度的UNIX时间戳。

    ```c
    typedef struct redisDb (
        // ...
        //过期字典，保存着键的过期时间
        diet *expires;
        // ...
    ） redisDb;
    ```

* 一个带有过期字典的数据库例子，在这个例子中，键空间保存了数据库 中的所有键值对，而过期字典则保存了数据库键的过期时间

  ![image](E:\Learn\repository\learning-stl\imgs\33.png)

* 当客户端执行 PEXPIREAT 命令（或者其他三个会转换成 PEXPIREAT 命令的命令）为一个数据库键设置过期时间时，服务器会在数据库的过期字典中关联给定的数据库键和过期时间。

* 以下是 PEXPIREAT 命令的伪代码定义：

  ```
  def PEXPIREAT(key, expire_time_in_ms):
      #如果给定的键不存在于键空间，那么不能设置过期时冋 if key not in redisDb.dict:
      returnO
      #在过期字典中关联键和过期时间
      redisDb.expires[key] = e xpi re_t ime_i n_ms
      #过期时间设置成功
      return 1
  ```

##### 移除过期时间

* PERSIST命令可以移除一个键的过期时间

* PERSIST命令就是 PEXPIREAT 命令的反操作： PERSIST 命令在过期字典中查找给定的 键，并解除键和值(过期时间)在过期字典中的关联。

* 以下是PERS/ST命令的伪代码定义：

  ```
  def PERSIST(key):
      #如果键不存在，或者键没有设置过期时间，那么直接返回 if key not in redisDb.expires:
      return O
      #移除过期字典中给定键的键值对关联
      redisDb.expires.remove(key)
      #键的过期时间移除成功
      return 1
  ```

##### 计算并返回剩余生存时间

* TTL命令以秒为单位返回键的剩余生存时间,而PTTL命令则以毫秒为单位返回键的剩余生存时间

* TTL和PTTL两个命令都是通过计算键的过期时间和当前时间之间的差来实现的，以下是这两个命令的伪代码实现：

  ```
  def PTTL(key):
      #键不存在于数据库
      if key not in redisDb.diet:
          return-2
      #尝试取得键的过期时间
      #如果键没有设置过期时冋，那么expire*将为None
      expire_time_in_ms = redisDb.expires.get(key)
  
      #键没有设置过期时间
      if expire_time_in_ms is None:
          return -1
      #获得当前时冋
      now_ms = get_current_unix_timestamp_in_ms()
  
      #过期时间减去当前时间，得出的差就是键的剩余生存时间
      return(expire_time_in_ms - now_ms)
      
  def TTL(key):
      #获取以毫秒为单位的剩余生存时间
      ttl_in_ms = PTTL(key)
      if ttl_in__ms < 0:
      #处理返回值为-2和-1的情况
          return ttl_in_ms
      else:
          #将毫秒转换为秒
          return ms_to_sec(ttl_in_ms)
  ```

##### 过期键的判定

* 通过过期字典，程序可以用以下步骤检查一个给定键是否过期：

  * 检査给定键是否存在于过期字典：如果存在，那么取得键的过期时间。
  * 检査当前UNIX时间戳是否大于键的过期时间：如果是的话，那么键已经过期；否则的话，键未过期。

* 可以用伪代码来描述这一过程：

  ```
  def is_expired（key）:
      #取得键的过期时间 
      expire_time_in_ms = redisDb.expires.get（key）
      #键没有设置过期时间
      if expire_time_in_ms is None:
          return False
      #取得当前时间的加ZX时冋戳
      now_ms = get_current_unix_timestamp_in_ms（）
      # 检查当前时间是否大于键的过期时间
      if now_ms > expire_time_in_ms:
      	#是，键已经过期
          return True
      else:
          #否，键未过期
          return False
  ```

* 注意，实现过期键判定的另一种方法是使用TTL命令或者PTTL命令，比如说，如果对某个键 执行TTL命令，并且命令返回的值大于等于0,那么说明该键未过期。在实际中，Redis检 查键是否过期的方法和is_expired函数所描述的方法一致，因为直接访问字典比执行一 个命令稍微快一些。

##### 过期键删除策略